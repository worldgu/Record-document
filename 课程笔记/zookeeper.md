# Zookeeper Log

## zookeeper 资源

官网:  http://zookeeper.apache.org/



------

## Redis回顾

> Redis是单实例的，内存数据库
>
> 因为是单点的防止单点故障使用主从复制集群 进行HA，又因为主节点也可能挂掉所以使用哨兵模式(sentinel) 对主从集群进行监控，当主节点不可用时，哨兵通过选举的方式选取新的从节点作为主节点，又因为有Client客户端进行调用时，高并发的情况下，集群不是绝对的实时同步  可能连最终一致性都谈不上
>
> 集群模式 分片
>
> -------------->>>>>>>>
>
> 集与以上种种   需要分布式协调  、引入分布式锁的概念
>



**ZOOKEEPER 分布式协调服务**

## 20200313

zookeeper 暴漏了一些原语  -->>> It exposes a simple set of primltives   

> ZooKeeper是用于分布式应用程序的分布式，开放源代码协调服务。它公开了一组简单的原语，分布式应用程序可以基于这些原语来实现用于同步，配置维护以及组和命名的更高级别的服务。它的设计易于编程，并使用了按照文件系统熟悉的目录树结构样式的数据模型。它以Java运行，并且具有Java和C的绑定。

## zookeeper 有两种运行状态 面试中问的较多

> 1. 可用状态、
> 2. 不可用状态
> 3. 不可用状态恢复到可用状态应该越快越好

数据模式和分层命名空间

zookeeper是一个目录数的结构，每一个节点数据最多存储1MB数据。

不要将zookeeper当数据库使用。

>  kafka和spark  
>
> spark 消费kafka中的数据。每消费一份数据记录一下偏移量，将偏移量存放在zookeeper中，当服务重启时，重新冲zookeeper中读取偏移量，这种做法就是将zookeeper当作数据库使用，并没有发挥zookeeper的使用效率。

**节点和短暂节点**

zookeeper是一个目录结构的数据

每一个node可以存储数据(最多为1MB)

node 还分为 **持久节点**和**临时节点** 

其中 临时节点引入session 概念，实现临时节点

上面的两类节点同事具备  **序列节点的功能** 

### 承诺

Zookeeper 非常快速而且非常简单，但是，由于其目标时构建更复杂的服务(如同步)的基础，因此他提供了一系列的保障：

1. 顺序一致性：客户端的更新将按发送顺序应用 :
   1. 从zookeeper的主从集群可以看出zookeeper的增、删、改操作只能从leader节点进行操作看出。
   2. leader会有一个请求对列，将请求按顺序配列，最后按照顺序执行。
2. 原子行：更新成功或失败，没有部分结果。
   1. 更新操作只有成功或者失败，没有中间态。
   2. 主从节点，主节点进行更新操作，会将改更新操作同步到其他的节点，这种通过客户端将数据同步到整个集群，就会要求强一致性，但是这个时候就会出现一个问题，当其中的一个从节点更新或者阻塞时，会影响整个集群，这又和zookeeper所说高性能，高可靠，高可用、HA的相违背，所以**他并不会要求强一致性，而是像redis集群一样，zookeeper实现的是最终一致性、当整个集群超过一半的服务执行成功，我们就可以说，这条命令是成功的，服务器集群最好为奇数，不管是从物理花费上，还是从软件设计上。**
   3. 通过**ZAP**的原子广播协议，来完成一致性。
3. 单系统映像：无论客户端连接到哪个服务器，客户端都将看到相同的服务试图。
4. 可靠性：一旦应用更新了，他将从那时起持续到客户端覆盖更新。
   1. 涉及到内存时，他就一定会有持久化概念，有一个写日志、拍镜像的概念。
5. 及时性: 系统的客户试图保证在特定**时间范围内**是最新的。
   1. 及时性、实时性、其实是想表述在最终一致性的这个概念。
   2. 比如上述的主从节点更新，超过一半的服务器进行更新了，客户端请求的是未更新数据的服务器，这个时候未更新数据的服务器将会通过sync()，向主节点进行请求数据同步，更新到从节点后，最总达到了及时性、最终一致性。

### 简单API

zookeeper的设计目标之一是提供一个非常简单的编程接口，因此，它支持一下操作:

1. create: 在树中的某个位置创建一个节点。
2. delete:删除节点。
3. exists:测试某个位置是否存在节点。
4. get data:从节点读取数据。
5. set data:将数据写入节点。
6. get children:检索节点的子节点列表。
7. sync: 带传播数据。





### zookeeper 安装

> 解压压缩包   tar x zookeeper-3.4.6.tar.gz
>
> 创建目录      mkdir /opt/mashibing
>
> 移动解压后的文件    mv zookeeper-3.4.6   /opt/mashibing
>
> 进入解压后的文件 进入 conf  目录
>
> 复制77



-----------------

分布式命名规则

zookeeper安装的笔记、

zookeeper的集群配置笔记

zookeeper的集群启动笔记

zookeeper的 leader的选举事件、session的讲解、

​					node中参数的讲解比如，每次选举leader后整个集群开启新的纪元

​					还有临时节点、以及应用方案将临时节点和session进行管理等方案

以上这些信息等过第二遍时，实际操作时进行总结与记录。

--------

### ZOOKEEPER （二） 原理知识、paxos、zab、角色功能

zookeeper分布式协调: 扩展性、可靠性、时序性

1. 扩展性--> 框架架构--> 角色

   1. 角色分为:  Leader、Follower、Observer

2. 扩展性--> 读写分离(Observer放大查询能力)

   1. 只有Follower才能选举，Observer的功能只是同步主节点的数据，对外提供查询的功能

3. 扩展性--> 样式配置

4. > zoo.cfg
   >
   > server.1=node01.2888:3888
   >
   > server.2=node02.2888:3888
   >
   > server.3=node03.2888:3888
   >
   > server.4=node04.2888:3888:observer

   综上: zookeeper主要对外提供的是查询功能，以及存储集群中必要的数据，一个集群中只有一个Leader、多个Follower、多个Observer,其中Observer只负责通过主节点的数据，以及对外提供查询功能；当Leader挂掉之后，Follower进行选举推出新的主节点。

5. 可靠性

   1. **》》》》》》》》攘其外必先安期内《《《《《《《《《**

      1. 攘其外: Leader可用   
      2. 安期内: follower选主的过程

   2.  快速回复Leader

   3.  数据  可靠  可用  一致性

      1.   **分布式**

         1. https://www.douban.com/note/208430424

         2. > ZAB ---> 原子广播协议
            >
            > 作用在可用状态
            >
            > 有Leader时
            >
            > > **原子**: 成功、失败、没有中间态(对列(Leader对Follower进行写请求时，其对每个follower维护一个对应的对列，记录Follower的状态)+2PC(leader中的两次请求返回，Leader进行write其实食分为两步的，第一步通知follower进行写日志返回OK后，第二部写数据返回OK后返回写的请求。))
            > >
            > > 广播: 分布式多节点，全部通知！(过半)
            > >
            > > 对列: FIFO ,顺序性
            > >
            > > ------
            > >
            > > zk的数据状态在内存中
            > >
            > > 用磁盘保存日志

      2. > 攘其外
         >
         > 什么是一致性?
         >
         > 一致性分为强引用和弱引用。
         >
         > 我们希望的是**最终一致性** ，最终一致性又将设计到 CAP
         >
         > 以及最终一致性过程中，节点是否对外提供服务
         >
         > 最终一致性的过程中，没有过半的服务其实是要shutdown自己的

 

本节目标:

1. paxos    -> 协议
2. ZAB       --> 相关联的选主模型、以及选完主之后对zookeeper进行增删改之后是如何进行数据同步的。
3. watch    ---> 事务
4. API  :  通过学习达到 不怕写 ZK Client的能力
5. callback:     回调    -->   reactive 响应式编程模型  ,  更充分压榨OS、HW 资源、性能

> 响应式编程模式   在zookeeper和Netty中使用较多



## paxos

> 百度搜索技巧:  在百度中当你想定向的在某个网站进行搜索，可以使用如下方式:
>
> paxos   site:douban.com

相关文章: https://www.douban.com/note/208430424



### ZAB  

主从模式

无主模式:  无主模式不对外体统服务，因为过半通过时，有些节点数据可能不全:

从无主模式到主从模式内部选主的过程，是谦让选举;

### Watch 手表、监控、观察









## zookeeper 分布式协调>>  配置  >>>  分布式锁！！！

### 分布式配置 

> 前情提要:
>
> ​		Zookeeper通过session以及Watch对zookeeper中的某一个节点进行监控,
>
> 当节点中的数据被创建、修改、删除时通过watch的监控以及callback的调用实时获取新的配置参数。



### 分布式锁

> zookeeper实现分布式锁----> 关键点解析
>
> 1. 争抢锁，当多个请求调用同一批资源时，只有一个人能获得锁。
> 2. 获得锁的人出问题时，容易造成死锁，zookeeper解决方案是，使用临时节点。
> 3. 获得锁的人成功了，释放锁。
> 4. 锁被释放、删除、别人怎么知道的？ 
>    1. 主动轮询、心跳....    弊端:  延迟(消费者与zk之间进行通信)、压力(上千个节点请求zk)
>    2. watch : 解决延迟问题。。。  弊端: 压力(上千个节点请求zk)
>    3. sequence+watch:  watch谁? watch第一个，最小的获得锁~?一旦最小的释放了锁，成本--->  上述的意思是，如果一千个节点都给最小的节点添加watch时，当最小的节点释放锁，删除锁时，zk会通知给其他的几百个节点，还是会造成压力。  **解决:** 将watch添加到本节点的上一个节点，这样上一个节点被删除时，只需要通知第二个节点即可。---> zk只给第二个发事件回调！！！

分布式锁的实现，



锁的重入



















